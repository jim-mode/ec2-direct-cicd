name: PHP Deploy Common

on:
  workflow_call:
    inputs:
      ref:
        required: true
        type: string
      image_tag:
        required: true
        type: string
      bastion_host:
        description: "Bastion server address"
        required: true
        type: string
      app_target:
        required: true
        type: string
    secrets:
      AWS_ACCESS_KEY_ID:
        required: true
      AWS_SECRET_ACCESS_KEY:
        required: true
      DEPLOY_SSH_PRIVATE_KEY:
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      GIT_REF: ${{ inputs.ref }}
      IMAGE_TAG: ${{ inputs.image_tag }}
      APP_TARGET_HOST: ${{ inputs.app_target }}
      # APP_SERVER_01_IP: ${{ secrets.APP_SERVER_01_IP }}
      BASTION_HOST: ${{ inputs.bastion_host }}
      DEPLOY_SSH_PRIVATE_KEY: ${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}
      SSH_USER: deploy
    steps:
      - name: Output Input and Env
        run: |
          echo inputs.ref: ${{ inputs.ref }}
          echo env.GIT_REF: ${{ env.GIT_REF }}
          echo inputs.image_tag: ${{ inputs.image_tag }}
          echo env.IMAGE_TAG: ${{ env.IMAGE_TAG }}

      - name: Checkout ðŸ›Ž
        uses: actions/checkout@master
        with:
          ref: ${{ env.GIT_REF }}

      - name: Configure SSH & Verify Docker Runtime on Hosts
        run: |
          # Only assume deploy user is provisioned with sudo permission

          # Setup Github Action Host
          mkdir -p ~/.ssh/ && echo "$DEPLOY_SSH_PRIVATE_KEY" > ~/.ssh/id_rsa && chmod 600 ~/.ssh/id_rsa

          # Setup Bastion Host
          echo "$DEPLOY_SSH_PRIVATE_KEY" > ~/id_rsa && ssh -o StrictHostKeyChecking=no ${SSH_USER}@${BASTION_HOST} "hostname"
          rsync -azq ~/id_rsa ${SSH_USER}@${BASTION_HOST}:/home/$SSH_USER/
          ssh -o StrictHostKeyChecking=no ${SSH_USER}@${BASTION_HOST} "mkdir -p ~/.ssh && mv ~/id_rsa ~/.ssh/ && chmod 600 ~/.ssh/id_rsa"

          # Setup App Servers
          for host in $APP_TARGET_HOST; do
            rsync -azq -e 'ssh -o StrictHostKeyChecking=no -A -J deploy@${BASTION_HOST}' ./release/verify_docker.sh deploy@${host}:~/verify_docker.sh

            # ssh -o StrictHostKeyChecking=no -J deploy@${BASTION_HOST} deploy@${host} "mkdir -p ~/docker"
            # rsync -azv -e 'ssh -A -J deploy@${BASTION_HOST}' ./release/verify_docker.sh deploy@${host}:~/verify_docker.sh

            ssh -o StrictHostKeyChecking=no -J deploy@${BASTION_HOST} deploy@${host} "mkdir -p ~/docker && ~/verify_docker.sh && rm -rf ~/verify_docker.sh"
          done

          # ssh -o StrictHostKeyChecking=no -J deploy@${BASTION_HOST} deploy@${APP_SERVER_01_IP} "mkdir -p ~/docker"
          # rsync -azv -e 'ssh -A -J deploy@${BASTION_HOST}' ./release/verify_docker.sh deploy@${APP_SERVER_01_IP}:~/verify_docker.sh
          # ssh -o StrictHostKeyChecking=no -J deploy@${BASTION_HOST} deploy@${APP_SERVER_01_IP} "~/verify_docker.sh"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Get Docker Images from ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          echo "$(date): Deploy files to EC2"

          cd release
          sed -i "s/PHP_DOCKER_IMAGE/$ECR_REGISTRY\/ec2-cicd-php:$IMAGE_TAG/g" docker-compose.yml
          sed -i "s/NGINX_DOCKER_IMAGE/$ECR_REGISTRY\/ec2-cicd-nginx:$IMAGE_TAG/g" docker-compose.yml

          echo "$( aws ecr get-login-password --region us-east-1 )" > DOCKER_PW
          echo "cat DOCKER_PW | docker login -u AWS --password-stdin $ECR_REGISTRY" > DOCKER_LOGIN

          # Pull Images
          for host in $APP_TARGET_HOST; do

            # ssh deploy@${BASTION_HOST} "ssh-keyscan -H \"${host}\"" | tee -a ~/.ssh/known_hosts
            rsync -azq -e 'ssh -A -J deploy@${BASTION_HOST}' DOCKER_PW DOCKER_LOGIN docker-compose.yml deploy@${host}:~/docker
            ssh -o StrictHostKeyChecking=no -J deploy@${BASTION_HOST} deploy@${host} "/bin/bash ~/docker/DOCKER_LOGIN && docker-compose -f docker/docker-compose.yml pull -q"

            # Get PHP Docker Image ID
            HOST_IMAGE_ID=$(ssh -o StrictHostKeyChecking=no -J deploy@${BASTION_HOST} deploy@${host} "docker images | grep ec2-cicd-php | grep latest" | awk '{print $3}')

            if [ -z "$PHP_IMAGE_ID" ]
            then
                PHP_IMAGE_ID=$HOST_IMAGE_ID
                echo "$(date) SET PHP Image ID $PHP_IMAGE_ID"
            else
                if [ "$PHP_IMAGE_ID" = "$HOST_IMAGE_ID" ];
                    echo "$(date) MATCHING PHP Image ID $PHP_IMAGE_ID"
                else
                    echo "$(date) #### PHP IMAGES ARE NOT MATCHING!!"
                    echo "#### #### #### #### #### #### #### ####"
                    echo "EXPECTED $PHP_IMAGE_ID ACTUAL $HOST_IMAGE_ID"
                    echo "#### #### #### #### #### #### #### ####"
                    echo "$(date) #### PHP IMAGES ARE NOT MATCHING!!"
                    # TODO: Retry
                fi
            fi
          done

      - name: Execute Docker Compose Up
        run: |
          # Run Docker
          for host in $APP_TARGET_HOST; do
            ssh -o StrictHostKeyChecking=no -J deploy@${BASTION_HOST} deploy@${host} "docker-compose -f docker/docker-compose.yml up -d"
          done





      # - name: Get timestamp
      #   uses: gerred/actions/current-time@master
      #   id: current-time

      # - name: Run string replace
      #   uses: frabert/replace-string-action@master
      #   id: format-time
      #   with:
      #     pattern: '[:\.]+'
      #     string: "${{ steps.current-time.outputs.time }}"
      #     replace-with: '-'
      #     flags: 'g'

      # - name: Beanstalk Deploy for app
      #   uses: einaregilsson/beanstalk-deploy@v20
      #   with:
      #     aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
      #     aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      #     application_name: ${{ secrets.BEANSTALK_APPLICATION_NAME }}
      #     environment_name: ${{ secrets.BEANSTALK_ENVIRONMENT_NAME }}
      #     use_existing_version_if_available: true
      #     region: us-east-1
      #     version_label: "${{ steps.set-tags.outputs.release_hash }}-${{ steps.format-time.outputs.replaced }}"
      #     deployment_package: deploy.zip
      #     wait_for_environment_recovery: 300

      # - name: Deployed!
      #   run: echo App deployed to ELB
